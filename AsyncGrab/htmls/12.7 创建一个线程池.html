
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  
  <title>12.7 创建一个线程池 — python3-cookbook 3.0.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/css/theme.css" rel="stylesheet" type="text/css"/>
  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/pygments.css" rel="stylesheet" type="text/css"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/genindex.html" rel="index" title="索引"/><script>
READTHEDOCS_DATA['page'] = 'c02/p02_match_text_at_start_end'
READTHEDOCS_DATA['source_suffix'] = '.rst'
</script>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/search.html" rel="search" title="搜索"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="copyright" title="版权所有"/>
    
     

  
  


<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="canonical"/>

<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="stylesheet" type="text/css"/>



<!-- Add page-specific data, which must exist in the page js, not global -->




<!-- end RTD <extrahead> -->
</head>
    <body>
    <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>12.7 创建一个线程池<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>你创建一个工作者线程池，用来响应客户端请求或执行其他的工作。</p>
</div>
<div class="section" id="id3">
<h2>解决方案<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">concurrent.futures</span></code> 函数库有一个 <code class="docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code> 类可以被用来完成这个任务。
下面是一个简单的TCP服务器，使用了一个线程池来响应客户端：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">socket</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    '''</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Got connection from'</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Client closed connection'</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你想手动创建你自己的线程池，
通常可以使用一个Queue来轻松实现。下面是一个稍微不同但是手动实现的例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    '''</span>
    <span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Got connection from'</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Client closed connection'</span><span class="p">)</span>

    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nworkers</span><span class="p">):</span>
    <span class="c1"># Launch the client workers</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nworkers</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Run the server</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span><span class="mi">15000</span><span class="p">),</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code> 相对于手动实现的一个好处在于它使得
任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="k">def</span> <span class="nf">fetch_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># Submit work to the pool</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fetch_url</span><span class="p">,</span> <span class="s1">'http://www.python.org'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fetch_url</span><span class="p">,</span> <span class="s1">'http://www.pypy.org'</span><span class="p">)</span>

<span class="c1"># Get the results back</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
<p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。
特别的，<code class="docutils literal notranslate"><span class="pre">a.result()</span></code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
</div>
<div class="section" id="id4">
<h2>讨论<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    Handle a client connection</span>
<span class="sd">    '''</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Got connection from'</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Client closed connection'</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nworkers</span><span class="p">):</span>
    <span class="c1"># Run the server</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">echo_client</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span><span class="mi">15000</span><span class="p">))</span>
</pre></div>
</div>
<p>尽管这个也可以工作，
但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。
通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p>
<p>你可能会关心创建大量线程会有什么后果。
现代操作系统可以很轻松的创建几千个线程的线程池。
甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。
当然了，如果所有线程同时被唤醒并立即在CPU上执行，那就不同了——特别是有了全局解释器锁GIL。
通常，你应该只在I/O处理相关代码中使用线程池。</p>
<p>创建大的线程池的一个可能需要关注的问题是内存的使用。
例如，如果你在OS X系统上面创建2000个线程，系统显示Python进程使用了超过9GB的虚拟内存。
不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来
放置线程的执行栈（通常是8MB大小）。但是这个内存只有一小片段被实际映射到真实内存中。
因此，Python进程使用到的真实内存其实很小
（比如，对于2000个线程来讲，只使用到了70MB的真实内存，而不是9GB）。
如果你担心虚拟内存大小，可以使用 <code class="docutils literal notranslate"><span class="pre">threading.stack_size()</span></code> 函数来降低它。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>
<span class="n">threading</span><span class="o">.</span><span class="n">stack_size</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你加上这条语句并再次运行前面的创建2000个线程试验，
你会发现Python进程只使用到了大概210MB的虚拟内存，而真实内存使用量没有变。
注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p>
</div>
</div>


           </div>
           
          </div>
    </body>
</html>