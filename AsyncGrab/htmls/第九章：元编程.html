
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  
  <title>第九章：元编程 — python3-cookbook 3.0.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/css/theme.css" rel="stylesheet" type="text/css"/>
  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/pygments.css" rel="stylesheet" type="text/css"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/genindex.html" rel="index" title="索引"/><script>
READTHEDOCS_DATA['page'] = 'c02/p02_match_text_at_start_end'
READTHEDOCS_DATA['source_suffix'] = '.rst'
</script>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/search.html" rel="search" title="搜索"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="copyright" title="版权所有"/>
    
     

  
  


<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p25_creating_cached_instances.html" rel="canonical"/>

<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p25_creating_cached_instances.html" rel="stylesheet" type="text/css"/>



<!-- Add page-specific data, which must exist in the page js, not global -->




<!-- end RTD <extrahead> -->
</head>
    <body>
    <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第九章：元编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>软件开发领域中最经典的口头禅就是“don’t repeat yourself”。
也就是说，任何时候当你的程序中存在高度重复(或者是通过剪切复制)的代码时，都应该想想是否有更好的解决方案。
在Python当中，通常都可以通过元编程来解决这类问题。
简而言之，元编程就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。
主要技术是使用装饰器、类装饰器和元类。不过还有一些其他技术，
包括签名对象、使用 <code class="docutils literal notranslate"><span class="pre">exec()</span></code> 执行代码以及对内部函数和类的反射技术等。
本章的主要目的是向大家介绍这些元编程技术，并且给出实例来演示它们是怎样定制化你的源代码行为的。</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../c09/p01_put_wrapper_around_function.html">9.1 在函数上添加包装器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p02_preserve_function_metadata_when_write_decorators.html">9.2 创建装饰器时保留函数元信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p03_unwrapping_decorator.html">9.3 解除一个装饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p04_define_decorator_that_takes_arguments.html">9.4 定义一个带参数的装饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p05_define_decorator_with_user_adjustable_attributes.html">9.5 可自定义属性的装饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p06_define_decorator_that_takes_optional_argument.html">9.6 带可选参数的装饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p07_enforcing_type_check_on_function_using_decorator.html">9.7 利用装饰器强制函数上的类型检查</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p08_define_decorators_as_part_of_class.html">9.8 将装饰器定义为类的一部分</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p09_define_decorators_as_classes.html">9.9 将装饰器定义为类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p10_apply_decorators_to_class_and_static_methods.html">9.10 为类和静态方法提供装饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p11_write_decorators_that_add_arguments_to_functions.html">9.11 装饰器为被包装函数增加参数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p12_using_decorators_to_patch_class_definitions.html">9.12 使用装饰器扩充类的功能</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p13_using_mataclass_to_control_instance_creation.html">9.13 使用元类控制实例的创建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p14_capture_class_attribute_definition_order.html">9.14 捕获类的属性定义顺序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p15_define_metaclass_that_takes_optional_arguments.html">9.15 定义有可选参数的元类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p16_enforce_argument_signature_on_args_kwargs.html">9.16 *args和**kwargs的强制参数签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p17_enforce_coding_conventions_in_classes.html">9.17 在类上强制使用编程规约</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p18_define_classes_programmatically.html">9.18 以编程方式定义类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p19_initializing_class_members_at_definition_time.html">9.19 在定义的时候初始化类的成员</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p20_implement_multiple_dispatch_with_function_annotations.html">9.20 利用函数注解实现方法重载</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p21_avoid_repetitive_property_methods.html">9.21 避免重复的属性方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p22_define_context_managers_the_easy_way.html">9.22 定义上下文管理器的简单方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p23_executing_code_with_local_side_effects.html">9.23 在局部变量域中执行代码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p24_parse_and_analyzing_python_source.html">9.24 解析与分析Python源码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c09/p25_disassembling_python_byte_code.html">9.25 拆解Python字节码</a></li>
</ul>
</div>
</div>


           </div>
           
          </div>
    </body>
</html>