
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  
  <title>11.10 在网络服务中加入SSL — python3-cookbook 3.0.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/css/theme.css" rel="stylesheet" type="text/css"/>
  <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/_static/pygments.css" rel="stylesheet" type="text/css"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/genindex.html" rel="index" title="索引"/><script>
READTHEDOCS_DATA['page'] = 'c02/p02_match_text_at_start_end'
READTHEDOCS_DATA['source_suffix'] = '.rst'
</script>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/search.html" rel="search" title="搜索"/>
    <link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="copyright" title="版权所有"/>
    
     

  
  


<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="canonical"/>

<link href="https://python3-cookbook.readthedocs.io/zh_CN/latest/copyright.html" rel="stylesheet" type="text/css"/>



<!-- Add page-specific data, which must exist in the page js, not global -->




<!-- end RTD <extrahead> -->
</head>
    <body>
    <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
           <div itemprop="articleBody">
            
  <div class="section" id="ssl">
<h1>11.10 在网络服务中加入SSL<a class="headerlink" href="#ssl" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>你想实现一个基于sockets的网络服务，客户端和服务器通过SSL协议认证并加密传输的数据。</p>
</div>
<div class="section" id="id2">
<h2>解决方案<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ssl</span></code> 模块能为底层socket连接添加SSL的支持。
<code class="docutils literal notranslate"><span class="pre">ssl.wrap_socket()</span></code> 函数接受一个已存在的socket作为参数并使用SSL层来包装它。
例如，下面是一个简单的应答服务器，能在服务器端为所有客户端连接做认证。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">KEYFILE</span> <span class="o">=</span> <span class="s1">'server_key.pem'</span>   <span class="c1"># Private key of the server</span>
<span class="n">CERTFILE</span> <span class="o">=</span> <span class="s1">'server_cert.pem'</span> <span class="c1"># Server certificate (given to client)</span>

<span class="k">def</span> <span class="nf">echo_client</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">''</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Connection closed'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">address</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Wrap with an SSL layer requiring client certs</span>
    <span class="n">s_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">,</span>
                            <span class="n">server_side</span><span class="o">=</span><span class="bp">True</span>
                            <span class="p">)</span>
    <span class="c1"># Wait for connections</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">s_ssl</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">'Got connection'</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">echo_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">'{}: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

<span class="n">echo_server</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
</pre></div>
</div>
<p>下面我们演示一个客户端连接服务器的交互例子。客户端会请求服务器来认证并确认连接：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
<span class="go">                cert_reqs=ssl.CERT_REQUIRED,</span>
<span class="go">                ca_certs = 'server_cert.pem')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">20000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">'Hello World?'</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ssl</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
<span class="go">b'Hello World?'</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种直接处理底层socket方式有个问题就是它不能很好的跟标准库中已存在的网络服务兼容。
例如，绝大部分服务器代码（HTTP、XML-RPC等）实际上是基于 <code class="docutils literal notranslate"><span class="pre">socketserver</span></code> 库的。
客户端代码在一个较高层上实现。我们需要另外一种稍微不同的方式来将SSL添加到已存在的服务中：</p>
<p>首先，对于服务器而言，可以通过像下面这样使用一个mixin类来添加SSL：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ssl</span>

<span class="k">class</span> <span class="nc">SSLMixin</span><span class="p">:</span>
    <span class="sd">'''</span>
<span class="sd">    Mixin class that adds support for SSL to existing servers based</span>
<span class="sd">    on the socketserver module.</span>
<span class="sd">    '''</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">keyfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ca_certs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_NONE</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyfile</span> <span class="o">=</span> <span class="n">keyfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_certfile</span> <span class="o">=</span> <span class="n">certfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ca_certs</span> <span class="o">=</span> <span class="n">ca_certs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cert_reqs</span> <span class="o">=</span> <span class="n">cert_reqs</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">client</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_request</span><span class="p">()</span>
        <span class="n">client_ssl</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">client</span><span class="p">,</span>
                                     <span class="n">keyfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyfile</span><span class="p">,</span>
                                     <span class="n">certfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_certfile</span><span class="p">,</span>
                                     <span class="n">ca_certs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ca_certs</span><span class="p">,</span>
                                     <span class="n">cert_reqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cert_reqs</span><span class="p">,</span>
                                     <span class="n">server_side</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">client_ssl</span><span class="p">,</span> <span class="n">addr</span>
</pre></div>
</div>
<p>为了使用这个mixin类，你可以将它跟其他服务器类混合。例如，下面是定义一个基于SSL的XML-RPC服务器例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># XML-RPC server with SSL</span>

<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">class</span> <span class="nc">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="n">SSLMixin</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Here</span><span class="s1">'s the XML-RPC server from Recipe 11.6 modified only slightly to use SSL:</span>

<span class="kn">import</span> <span class="nn">ssl</span>
<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">from</span> <span class="nn">sslmixin</span> <span class="kn">import</span> <span class="n">SSLMixin</span>

<span class="k">class</span> <span class="nc">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="n">SSLMixin</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">KeyValueServer</span><span class="p">:</span>
    <span class="n">_rpc_methods_</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'get'</span><span class="p">,</span> <span class="s1">'set'</span><span class="p">,</span> <span class="s1">'delete'</span><span class="p">,</span> <span class="s1">'exists'</span><span class="p">,</span> <span class="s1">'keys'</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span> <span class="o">=</span> <span class="n">SSLSimpleXMLRPCServer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpc_methods_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">KEYFILE</span><span class="o">=</span><span class="s1">'server_key.pem'</span>    <span class="c1"># Private key of the server</span>
    <span class="n">CERTFILE</span><span class="o">=</span><span class="s1">'server_cert.pem'</span>  <span class="c1"># Server certificate</span>
    <span class="n">kvserv</span> <span class="o">=</span> <span class="n">KeyValueServer</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">)</span>
    <span class="n">kvserv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>使用这个服务器时，你可以使用普通的 <code class="docutils literal notranslate"><span class="pre">xmlrpc.client</span></code> 模块来连接它。
只需要在URL中指定 <code class="docutils literal notranslate"><span class="pre">https:</span></code> 即可，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">ServerProxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">'https://localhost:15000'</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">['spam', 'foo']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="go">'bar'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>对于SSL客户端来讲一个比较复杂的问题是如何确认服务器证书或为服务器提供客户端认证（比如客户端证书）。
不幸的是，暂时还没有一个标准方法来解决这个问题，需要自己去研究。
不过，下面给出一个例子，用来建立一个安全的XML-RPC连接来确认服务器证书：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">SafeTransport</span><span class="p">,</span> <span class="n">ServerProxy</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="k">class</span> <span class="nc">VerifyCertSafeTransport</span><span class="p">(</span><span class="n">SafeTransport</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cafile</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">SafeTransport</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="n">cafile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">certfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="p">,</span> <span class="n">keyfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>

    <span class="k">def</span> <span class="nf">make_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="c1"># Items in the passed dictionary are passed as keyword</span>
        <span class="c1"># arguments to the http.client.HTTPSConnection() constructor.</span>
        <span class="c1"># The context argument allows an ssl.SSLContext instance to</span>
        <span class="c1"># be passed with information about the SSL configuration</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">make_connection</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="p">{</span><span class="s1">'context'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_context</span><span class="p">}))</span>

        <span class="k">return</span> <span class="n">s</span>

<span class="c1"># Create the client proxy</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">'https://localhost:15000'</span><span class="p">,</span>
                <span class="n">transport</span><span class="o">=</span><span class="n">VerifyCertSafeTransport</span><span class="p">(</span><span class="s1">'server_cert.pem'</span><span class="p">),</span>
                <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>服务器将证书发送给客户端，客户端来确认它的合法性。这种确认可以是相互的。
如果服务器想要确认客户端，可以将服务器启动代码修改如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">KEYFILE</span><span class="o">=</span><span class="s1">'server_key.pem'</span>   <span class="c1"># Private key of the server</span>
    <span class="n">CERTFILE</span><span class="o">=</span><span class="s1">'server_cert.pem'</span> <span class="c1"># Server certificate</span>
    <span class="n">CA_CERTS</span><span class="o">=</span><span class="s1">'client_cert.pem'</span> <span class="c1"># Certificates of accepted clients</span>

    <span class="n">kvserv</span> <span class="o">=</span> <span class="n">KeyValueServer</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span>
                            <span class="n">keyfile</span><span class="o">=</span><span class="n">KEYFILE</span><span class="p">,</span>
                            <span class="n">certfile</span><span class="o">=</span><span class="n">CERTFILE</span><span class="p">,</span>
                            <span class="n">ca_certs</span><span class="o">=</span><span class="n">CA_CERTS</span><span class="p">,</span>
                            <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">,</span>
                            <span class="p">)</span>
    <span class="n">kvserv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>为了让XML-RPC客户端发送证书，修改 <code class="docutils literal notranslate"><span class="pre">ServerProxy</span></code> 的初始化代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the client proxy</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s1">'https://localhost:15000'</span><span class="p">,</span>
                <span class="n">transport</span><span class="o">=</span><span class="n">VerifyCertSafeTransport</span><span class="p">(</span><span class="s1">'server_cert.pem'</span><span class="p">,</span>
                                                  <span class="s1">'client_cert.pem'</span><span class="p">,</span>
                                                  <span class="s1">'client_key.pem'</span><span class="p">),</span>
                <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>讨论<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>试着去运行本节的代码能测试你的系统配置能力和理解SSL。
可能最大的挑战是如何一步步的获取初始配置key、证书和其他所需依赖。</p>
<p>我解释下到底需要啥，每一个SSL连接终端一般都会有一个私钥和一个签名证书文件。
这个证书包含了公钥并在每一次连接的时候都会发送给对方。
对于公共服务器，它们的证书通常是被权威证书机构比如Verisign、Equifax或其他类似机构（需要付费的）签名过的。
为了确认服务器签名，客户端回保存一份包含了信任授权机构的证书列表文件。
例如，web浏览器保存了主要的认证机构的证书，并使用它来为每一个HTTPS连接确认证书的合法性。
对本小节示例而言，只是为了测试，我们可以创建自签名的证书，下面是主要步骤：</p>
<dl class="docutils">
<dt>::</dt>
<dd><dl class="first docutils">
<dt>bash % openssl req -new -x509 -days 365 -nodes -out server_cert.pem </dt>
<dd>-keyout server_key.pem</dd>
</dl>
<p>Generating a 1024 bit RSA private key
……………………………………++++++
…++++++</p>
<p>writing new private key to ‘server_key.pem’</p>
<blockquote>
<div></div></blockquote>
<p>You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter ‘.’, the field will be left blank.</p>
<blockquote>
<div></div></blockquote>
<p class="last">Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Illinois
Locality Name (eg, city) []:Chicago
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dabeaz, LLC
Organizational Unit Name (eg, section) []:
Common Name (eg, YOUR name) []:localhost
Email Address []:
bash %</p>
</dd>
</dl>
<p>在创建证书的时候，各个值的设定可以是任意的，但是”Common Name“的值通常要包含服务器的DNS主机名。
如果你只是在本机测试，那么就使用”localhost“，否则使用服务器的域名。</p>
<dl class="docutils">
<dt>::</dt>
<dd>—–BEGIN RSA PRIVATE KEY—–
MIICXQIBAAKBgQCZrCNLoEyAKF+f9UNcFaz5Osa6jf7qkbUl8si5xQrY3ZYC7juu
nL1dZLn/VbEFIITaUOgvBtPv1qUWTJGwga62VSG1oFE0ODIx3g2Nh4sRf+rySsx2
L4442nx0z4O5vJQ7k6eRNHAZUUnCL50+YvjyLyt7ryLSjSuKhCcJsbZgPwIDAQAB
AoGAB5evrr7eyL4160tM5rHTeATlaLY3UBOe5Z8XN8Z6gLiB/ucSX9AysviVD/6F
3oD6z2aL8jbeJc1vHqjt0dC2dwwm32vVl8mRdyoAsQpWmiqXrkvP4Bsl04VpBeHw
Qt8xNSW9SFhceL3LEvw9M8i9MV39viih1ILyH8OuHdvJyFECQQDLEjl2d2ppxND9
PoLqVFAirDfX2JnLTdWbc+M11a9Jdn3hKF8TcxfEnFVs5Gav1MusicY5KB0ylYPb
YbTvqKc7AkEAwbnRBO2VYEZsJZp2X0IZqP9ovWokkpYx+PE4+c6MySDgaMcigL7v
WDIHJG1CHudD09GbqENasDzyb2HAIW4CzQJBAKDdkv+xoW6gJx42Auc2WzTcUHCA
eXR/+BLpPrhKykzbvOQ8YvS5W764SUO1u1LWs3G+wnRMvrRvlMCZKgggBjkCQQCG
Jewto2+a+WkOKQXrNNScCDE5aPTmZQc5waCYq4UmCZQcOjkUOiN3ST1U5iuxRqfb
V/yX6fw0qh+fLWtkOs/JAkA+okMSxZwqRtfgOFGBfwQ8/iKrnizeanTQ3L6scFXI
CHZXdJ3XQ6qUmNxNn7iJ7S/LDawo1QfWkCfD9FYoxBlg
—–END RSA PRIVATE KEY—–</dd>
</dl>
<p>服务器证书文件server_cert.pem内容类似下面这样：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">—–BEGIN CERTIFICATE—–
MIIC+DCCAmGgAwIBAgIJAPMd+vi45js3MA0GCSqGSIb3DQEBBQUAMFwxCzAJBgNV
BAYTAlVTMREwDwYDVQQIEwhJbGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIG
A1UEChMLRGFiZWF6LCBMTEMxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xMzAxMTEx
ODQyMjdaFw0xNDAxMTExODQyMjdaMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJ
bGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMx
EjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA
mawjS6BMgChfn/VDXBWs+TrGuo3+6pG1JfLIucUK2N2WAu47rpy9XWS5/1WxBSCE
2lDoLwbT79alFkyRsIGutlUhtaBRNDgyMd4NjYeLEX/q8krMdi+OONp8dM+DubyU</p>
<p class="last">O5OnkTRwGVFJwi+dPmL48i8re68i0o0rioQnCbG2YD8CAwEAAaOBwTCBvjAdBgNV
HQ4EFgQUrtoLHHgXiDZTr26NMmgKJLJLFtIwgY4GA1UdIwSBhjCBg4AUrtoLHHgX
iDZTr26NMmgKJLJLFtKhYKReMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJbGxp
bm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMxEjAQ
BgNVBAMTCWxvY2FsaG9zdIIJAPMd+vi45js3MAwGA1UdEwQFMAMBAf8wDQYJKoZI
hvcNAQEFBQADgYEAFci+dqvMG4xF8UTnbGVvZJPIzJDRee6Nbt6AHQo9pOdAIMAu
WsGCplSOaDNdKKzl+b2UT2Zp3AIW4Qd51bouSNnR4M/gnr9ZD1ZctFd3jS+C5XRp
D3vvcW5lAnCCC80P6rXy7d7hTeFu5EYKtRGXNvVNd/06NALGDflrrOwxF3Y=
—–END CERTIFICATE—–</p>
</dd>
</dl>
<p>在服务器端代码中，私钥和证书文件会被传给SSL相关的包装函数。证书来自于客户端，
私钥应该在保存在服务器中，并加以安全保护。</p>
<p>在客户端代码中，需要保存一个合法证书授权文件来确认服务器证书。
如果你没有这个文件，你可以在客户端复制一份服务器的证书并使用它来确认。
连接建立后，服务器会提供它的证书，然后你就能使用已经保存的证书来确认它是否正确。</p>
<p>服务器也能选择是否要确认客户端的身份。如果要这样做的话，客户端需要有自己的私钥和认证文件。
服务器也需要保存一个被信任证书授权文件来确认客户端证书。</p>
<p>如果你要在真实环境中为你的网络服务加上SSL的支持，这小节只是一个入门介绍而已。
你还应该参考其他的文档，做好花费不少时间来测试它正常工作的准备。反正，就是得慢慢折腾吧~ ^_^</p>
</div>
</div>


           </div>
           
          </div>
    </body>
</html>